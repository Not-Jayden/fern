import { Encoding, ExampleType, FernFilepath, Source, Type, TypeDeclaration, TypeId } from "@fern-api/ir-sdk";
import { FernWorkspace } from "@fern-api/api-workspace-commons";
import { isRawObjectDefinition, RawSchemas, visitRawTypeDeclaration } from "@fern-api/fern-definition-schema";
import { FernFileContext } from "../../FernFileContext";
import { AudienceId } from "../../filtered-ir/ids";
import { ExampleResolver } from "../../resolvers/ExampleResolver";
import { SourceResolver } from "../../resolvers/SourceResolver";
import { TypeResolver } from "../../resolvers/TypeResolver";
import { getPropertiesByAudience } from "../../utils/getPropertiesByAudience";
import { parseTypeName } from "../../utils/parseTypeName";
import { convertDeclaration } from "../convertDeclaration";
import { convertSourceToProtobufType, maybeConvertEncodingToProtobufType } from "../convertProtobufType";
import { convertAliasTypeDeclaration } from "./convertAliasTypeDeclaration";
import { convertDiscriminatedUnionTypeDeclaration } from "./convertDiscriminatedUnionTypeDeclaration";
import { convertEnumTypeDeclaration } from "./convertEnumTypeDeclaration";
import { convertTypeExample } from "./convertExampleType";
import { convertObjectTypeDeclaration } from "./convertObjectTypeDeclaration";
import { convertUndiscriminatedUnionTypeDeclaration } from "./convertUndiscriminatedUnionTypeDeclaration";
import { getReferencedTypesFromRawDeclaration } from "./getReferencedTypesFromRawDeclaration";
import { WithInlinedTypeDeclarations, WithInlinedTypes } from "./ConvertInlinedTypeResponse";

export interface TypeDeclarationWithDescendantFilepaths {
    typeDeclaration: TypeDeclaration;
    descendantFilepaths: Set<FernFilepath>;
    propertiesByAudience: Record<AudienceId, Set<string>>;
}

export async function convertTypeDeclaration({
    typeName,
    typeDeclaration,
    file,
    typeResolver,
    exampleResolver,
    sourceResolver,
    workspace
}: {
    typeName: string;
    typeDeclaration: RawSchemas.TypeDeclarationSchema;
    file: FernFileContext;
    typeResolver: TypeResolver;
    exampleResolver: ExampleResolver;
    sourceResolver: SourceResolver;
    workspace: FernWorkspace;
}): Promise<WithInlinedTypeDeclarations<TypeDeclarationWithDescendantFilepaths>> {
    const declaration = await convertDeclaration(typeDeclaration);
    const declaredTypeName = parseTypeName({
        typeName,
        file
    });

    const referencedTypes = getReferencedTypesFromRawDeclaration({ typeDeclaration, file, typeResolver });

    let propertiesByAudience: Record<AudienceId, Set<string>> = {};
    if (isRawObjectDefinition(typeDeclaration)) {
        propertiesByAudience = getPropertiesByAudience(typeDeclaration.properties ?? {});
    }

    const source = await convertTypeDeclarationSource({
        file,
        typeDeclaration,
        typeName,
        sourceResolver
    });

    const { response: shape, inlinedTypes } = await convertType({ typeDeclaration, file, typeResolver });

    const inlinedTypeDeclarations: Record<TypeId, TypeDeclaration> = {};
    for (const [typeId, type] of Object.entries(inlinedTypes)) {
        const declaration = await convertDeclaration(typeId);
        const declaredTypeName = parseTypeName({
            typeName: typeId,
            file
        });
        inlinedTypeDeclarations[typeId] = {
            ...declaration,
            name: declaredTypeName,
            inline: true,
            shape: type,
            referencedTypes: new Set(),
            encoding: convertTypeDeclarationEncoding({ typeDeclaration: typeId, source }),
            source,
            userProvidedExamples: [],
            autogeneratedExamples: []
        };
    }

    const response = {
        propertiesByAudience,
        typeDeclaration: {
            ...declaration,
            inline: false,
            name: declaredTypeName,
            inline: false,
            shape,
            referencedTypes: new Set(referencedTypes.map((referencedType) => referencedType.typeId)),
            encoding: convertTypeDeclarationEncoding({ typeDeclaration, source }),
            source,
            userProvidedExamples:
                typeof typeDeclaration !== "string" && typeDeclaration.examples != null
                    ? typeDeclaration.examples.map(
                          (example): ExampleType => ({
                              name: example.name != null ? file.casingsGenerator.generateName(example.name) : undefined,
                              docs: example.docs,
                              jsonExample: exampleResolver.resolveAllReferencesInExampleOrThrow({
                                  example: example.value,
                                  file
                              }).resolvedExample,
                              shape: convertTypeExample({
                                  typeName: declaredTypeName,
                                  example: example.value,
                                  typeResolver,
                                  exampleResolver,
                                  typeDeclaration,
                                  fileContainingType: file,
                                  fileContainingExample: file,
                                  workspace
                              })
                          })
                      )
                    : [],
            autogeneratedExamples: []
        },
        descendantFilepaths: new Set(referencedTypes.map((referencedType) => referencedType.fernFilepath))
    };

    return { response, inlinedTypeDeclarations };
}

export async function convertType({
    typeDeclaration,
    file,
    typeResolver
}: {
    typeDeclaration: RawSchemas.TypeDeclarationSchema;
    file: FernFileContext;
    typeResolver: TypeResolver;
}): Promise<WithInlinedTypes<Type>> {
    const inlinedTypes: Record<TypeId, Type> = {};
    const type = await visitRawTypeDeclaration<Promise<Type> | Type>(typeDeclaration, {
        alias: (alias) => convertAliasTypeDeclaration({ alias, file, typeResolver }),
        object: async (object) => {
            const { response, inlinedTypes: additionalInlinedTypes } = await convertObjectTypeDeclaration({
                object,
                file,
                typeResolver
            });
            for (const [typeId, inlineType] of Object.entries(additionalInlinedTypes)) {
                inlinedTypes[typeId] = inlineType;
            }
            return response;
        },
        discriminatedUnion: (union) => convertDiscriminatedUnionTypeDeclaration({ union, file, typeResolver }),
        undiscriminatedUnion: (union) => convertUndiscriminatedUnionTypeDeclaration({ union, file }),
        enum: async (enum_) => Type.enum(await convertEnumTypeDeclaration({ _enum: enum_, file }))
    });
    return { response: type, inlinedTypes };
}

async function convertTypeDeclarationSource({
    file,
    typeDeclaration,
    typeName,
    sourceResolver
}: {
    file: FernFileContext;
    typeDeclaration: RawSchemas.TypeDeclarationSchema;
    typeName: string;
    sourceResolver: SourceResolver;
}): Promise<Source | undefined> {
    if (typeof typeDeclaration === "string" || (typeDeclaration.source == null && typeDeclaration.encoding == null)) {
        return undefined;
    }
    if (typeDeclaration.encoding != null) {
        const maybeProtobufType = maybeConvertEncodingToProtobufType({
            encoding: typeDeclaration.encoding
        });
        if (maybeProtobufType != null) {
            return Source.proto(maybeProtobufType);
        }
    }
    if (typeDeclaration.source == null) {
        return undefined;
    }
    const resolvedSource = await sourceResolver.resolveSourceOrThrow({
        source: typeDeclaration.source,
        file
    });
    if (resolvedSource == null || resolvedSource.type !== "protobuf") {
        return undefined;
    }
    return Source.proto(
        convertSourceToProtobufType({
            source: resolvedSource,
            name: typeName
        })
    );
}

function convertTypeDeclarationEncoding({
    typeDeclaration,
    source
}: {
    typeDeclaration: RawSchemas.TypeDeclarationSchema;
    source: Source | undefined;
}): Encoding {
    if (typeof typeDeclaration !== "string" && typeDeclaration.encoding != null) {
        return convertEncoding(typeDeclaration.encoding);
    }
    return convertSourceToEncoding(source);
}

function convertEncoding(encodingSchema: RawSchemas.EncodingSchema): Encoding {
    return encodingSchema.proto != null
        ? {
              json: undefined,
              proto: {}
          }
        : {
              json: {},
              proto: undefined
          };
}

function convertSourceToEncoding(source: Source | undefined): Encoding {
    return source != null && source.type === "proto"
        ? {
              json: undefined,
              proto: {}
          }
        : {
              json: {},
              proto: undefined
          };
}
